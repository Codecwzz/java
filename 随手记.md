### java中的@Override标签，小细节大作用  
1. 帮助自己检查是否正确的复写了父类中已有的方法
2. 告诉读代码的人，这是一个复写的方法  

其实，在我们手工复写父类的方法时，容易把方法的参数记错，如果此时不加@Override的话，编辑器就不会提示你：例如我们不加这个标签，悄悄的把参数从int改为float型。
这个时候，其实我们并没有按照我们的意图成功复写方法，于是一个隐藏的bug就这样诞生了，相反加上Override的效果就是 IDE给出了错误提示，说明我们复写方法失败。
往往就是我们准备复写方法的时候结果，相反我们是重载了方法。在面向对象中，只有接口和公有方法，继承方法才有复写，私有方法不可以复写，但是又想了一下，才明白：
不是不可以复写而是，根本就不存在复写私有方法的概念！这正是面向对象设计的初衷，私有方法本身就是为了封装在类内部，不希望别人来更改或者外部引用的。  
### super关键字
http://www.cnblogs.com/xdp-gacl/p/3635948.html
### Java—集合框架 List的 indexOf()、lastIndexOf()
集合中某个元素出现的位置—List的indexOf(),lastIndexOf() <br>
indexOf(Object obj)方法的实现机制是从序列(List)的第0个元素开始依次循环，并且调用每个元素的equals()方法和参数对象进行比较，如果某一个元素equals()方法返回值为true，那么就把当前元素的索引位置作为结果返回。假如序列中有多个重复的元素，只返回这个重复的元素第一次出现时所在的索引位置的值。<br>
lastIndexOf(Object obj)方法，与indexOf()方法相反，它返回的是某个元素最后一次出现的索引位置的值，也就是它会从序列的队尾向队头进行遍历。<br> 
以上两个方法的参数对象如果在序列中都没有出现的话，那么这两个方法都会返回-1。
### @RequestMapping 和 @GetMapping @PostMapping 区别
@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。 <br>
@PostMapping是一个组合注解，是@RequestMapping(method = RequestMethod.POST)的缩写。
### 
可见性：当多个线程访问同一个变量x时，线程1修改了变量x的值，线程1、线程2...线程n能够立即读取到线程1修改后的值。<br>
原子性：如果你了解事务，那这个概念应该好理解。原子性通常指多个操作不存在只执行一部分的情况，如果全部执行完成那没毛病，如果只执行了一部分，那对不起，你得撤销(即事务中的回滚)已经执行的部分。<br>
有序性：即程序执行时按照代码书写的先后顺序执行。在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。(本文不对指令重排作介绍，但不代表它不重要，它是理解JAVA并发原理时非常重要的一个概念)。

